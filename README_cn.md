### 项目介绍

bsdiff是一个用来生成和应用二进制差分补丁的工具。它采用了Larsson和Sadakane的qsufsort算法,利用可执行文件中的变化特性,生成的补丁比Xdelta小50-80%,比商业产品RTPatch小15%。

仓库包含bsdiff和bspatch两个主程序,以及相关文档如README、许可证文件等。代码主要使用C语言开发,还依赖bzip2工具。README给出了算法原理以及项目作者Colin Percival的一篇未发表论文,建议在引用该项目时应引用这篇论文。

仓库目前没有任何发布版本,也没有其他语言包或活动。整体来看,这个项目实现了一个高效的二进制差分工具,能生成体积更小的补丁文件,主要用于Linux和类Unix系统。

### 原理介绍

bsdiff算法的主要思路是:

1. 对old文件和new文件进行后缀排序。通过qsufsort算法对两个文件进行后缀排序,这样可以找到相同后缀片段的位置。

2. 找到相同后缀片段,将它们看作是原子单元不做差分。可以大大提高差分效率。

3. 对剩余的不相同部分进行差分。首先找出old文件中出现在new文件中的片段,记录它们的位置。然后对没有匹配片段进行字节级的差分。

4. 将位置记录和差分结果gzip压缩成补丁文件。

应用算法主要步骤是:

1. 根据补丁文件还原位置记录表。

2. 用位置表在old文件中查找匹配片段,还原到新的文件中。

3. 对差分部分依次应用每个字节的差分,还原未匹配部分。

4. 还原完成新的文件。

相比一般二进制差分算法,bsdiff的亮点在于:

1. 通过后缀排序找到最大连续相同区域,大大提高效率。

2. 只对未匹配部分做差分,节约差分量。

3. 将结果gzip压缩,再次节约空间。

因此它生成的补丁文件通常比xdelta等算法小50%左右,精髓在于充分利用可执行文件中不随意变动的特点。这种算法适用于二进制可执行文件和配置文件差分场景。

### 使用方法

bsdiff和bspatch的使用方法如下:

1. 生成补丁文件

使用bsdiff生成两个文件之间的补丁:

bsdiff oldfile newfile patchfile

oldfile为原始文件,newfile为更新后的新文件,patchfile为生成的补丁文件。

2. 应用补丁文件

使用bspatch将补丁文件应用到原始文件生成更新后的新文件:

bspatch oldfile patchfile newfile

oldfile为原始文件,patchfile为补丁文件,newfile为应用补丁后的更新文件。

3. 可选参数

-s:对比后的差异显示输出,调试使用

-b blocksize:设置块大小,默认2048字节

4. 示例

生成文件1到文件2的补丁:

bsdiff file1.bin file2.bin patch.bsp

应用补丁重建文件2:

bspatch file1.bin patch.bsp file2.rebuild.bin

5. 注意事项

- oldfile和newfile大小最好一致

- 只能两个文件间应用单个补丁

- 需要提前安装bzip2库

- Linux下通常预装,否则需要自行编译安装

所以总体来说,使用bsdiff生成补丁很简单,然后用bspatch一个命令就可以还原文件,体现了它高效省空间的优点。

### 小文件(<1000bytes)压缩效果

对于小文件如1000字节以下的文件,bsdiff的差分效果和其他差分工具相比会有一些差异:

- 生成的补丁文件可能没有其他工具那么小。

由于bsdiff通过后缀排序找到重复部分进行优化,对于小文件来说重复部分较少,差分部分就会相对更大一些。

- 差分和应用速度可能没有很大优势。

对小文件来说,差分及应用本身就需要很短时间,bsdiff进行后缀排序等优化对速度改善不太明显。

- 可能无法完全利用压缩算法优势。

小文件本身数据就很少,压缩后体积缩减程度不如大文件明显。

- 有一定开销用于后缀排序等预处处理。

对小文件来说,这部分开销相对差分本身开销就比较大。

所以总的来说:

- 对1000字节以下很小的文件,bsdiff产生的补丁文件可能没有其他工具小。

- 差分和应用速度没有明显优势。

- 无法很好地利用它的压缩和重复部分优化设计。

但对于几千字节级小文件,优势也许还是有的。只是相比大文件, bsdiff在小文件上的优势就不是特别明显。

一般建议文件大于几千字节时才使用bsdiff,否则其他工具性能表现可能不错。